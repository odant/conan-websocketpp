diff --git a/src/websocketpp/common/functional.hpp b/src/websocketpp/common/functional.hpp
index d332dd1..6e39ec3 100644
--- a/src/websocketpp/common/functional.hpp
+++ b/src/websocketpp/common/functional.hpp
@@ -49,10 +49,10 @@
 
 
 
-#ifdef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+#if defined _WEBSOCKETPP_CPP11_FUNCTIONAL_ && !defined WEBSOCKETPP_USE_BOOST_FUNCTIONAL
     #include <functional>
 #else
-    #include <boost/bind.hpp>
+    #include <boost/bind/bind.hpp>
     #include <boost/function.hpp>
     #include <boost/ref.hpp>
 #endif
@@ -62,7 +62,7 @@
 namespace websocketpp {
 namespace lib {
 
-#ifdef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+#if defined _WEBSOCKETPP_CPP11_FUNCTIONAL_ && !defined WEBSOCKETPP_USE_BOOST_FUNCTIONAL
     using std::function;
     using std::bind;
     using std::ref;
@@ -83,12 +83,7 @@ namespace lib {
     using boost::function;
     using boost::bind;
     using boost::ref;
-    namespace placeholders {
-        /// \todo this feels hacky, is there a better way?
-        using ::_1;
-        using ::_2;
-        using ::_3;
-    }
+    namespace placeholders = boost::placeholders;
 
     // See above definition for more details on what this is and why it exists
     #define _WEBSOCKETPP_REF(x) boost::ref(x)
diff --git a/src/websocketpp/common/md5.hpp b/src/websocketpp/common/md5.hpp
index 279725f..81a6768 100644
--- a/src/websocketpp/common/md5.hpp
+++ b/src/websocketpp/common/md5.hpp
@@ -364,7 +364,7 @@ void md5_append(md5_state_t *pms, md5_byte_t const * data, size_t nbytes) {
     return;
 
     /* Update the message length. */
-    pms->count[1] += nbytes >> 29;
+    pms->count[1] += static_cast<md5_word_t>(nbytes >> 29);
     pms->count[0] += nbits;
     if (pms->count[0] < nbits)
     pms->count[1]++;
diff --git a/src/websocketpp/common/memory.hpp b/src/websocketpp/common/memory.hpp
index 42048e3..ec36a95 100644
--- a/src/websocketpp/common/memory.hpp
+++ b/src/websocketpp/common/memory.hpp
@@ -48,10 +48,15 @@
 #endif
 
 
-
 #ifdef _WEBSOCKETPP_CPP11_MEMORY_
     #include <memory>
 #else
+    #ifndef WEBSOCKETPP_USE_BOOST_MEMORY
+        #define WEBSOCKETPP_USE_BOOST_MEMORY
+    #endif
+#endif
+
+#ifdef WEBSOCKETPP_USE_BOOST_MEMORY
     #include <boost/shared_ptr.hpp>
 	#include <boost/make_shared.hpp>
     #include <boost/scoped_array.hpp>
@@ -62,7 +67,7 @@
 namespace websocketpp {
 namespace lib {
 
-#ifdef _WEBSOCKETPP_CPP11_MEMORY_
+#ifndef WEBSOCKETPP_USE_BOOST_MEMORY
     using std::shared_ptr;
     using std::weak_ptr;
     using std::enable_shared_from_this;
@@ -74,12 +79,17 @@ namespace lib {
 #else
     using boost::shared_ptr;
     using boost::weak_ptr;
-    using std::auto_ptr;
     using boost::enable_shared_from_this;
     using boost::static_pointer_cast;
     using boost::make_shared;
 
-    typedef boost::scoped_array<unsigned char> unique_ptr_uchar_array;
+    #ifdef _WEBSOCKETPP_CPP11_MEMORY_
+        using std::unique_ptr;
+        typedef std::unique_ptr<unsigned char[]> unique_ptr_uchar_array;
+    #else
+        using std::auto_ptr;
+        typedef boost::scoped_array<unsigned char> unique_ptr_uchar_array;
+    #endif
 #endif
 
 } // namespace lib
diff --git a/src/websocketpp/connection.hpp b/src/websocketpp/connection.hpp
index d019fce..84c70ad 100644
--- a/src/websocketpp/connection.hpp
+++ b/src/websocketpp/connection.hpp
@@ -1357,7 +1357,7 @@ public:
         m_connection_hdl = hdl;
         transport_con_type::set_handle(hdl);
     }
-protected:
+//protected:
     void handle_transport_init(lib::error_code const & ec);
 
     /// Set m_processor based on information in m_request. Set m_response
@@ -1367,7 +1367,7 @@ protected:
     /// Perform WebSocket handshake validation of m_request using m_processor.
     /// set m_response and return an error code indicating status.
     lib::error_code process_handshake_request();
-private:
+//private:
     
 
     /// Completes m_response, serializes it, and sends it out on the wire.
diff --git a/src/websocketpp/endpoint.hpp b/src/websocketpp/endpoint.hpp
index c124b1d..7203216 100644
--- a/src/websocketpp/endpoint.hpp
+++ b/src/websocketpp/endpoint.hpp
@@ -85,6 +85,8 @@ public:
     // TODO: organize these
     typedef typename connection_type::termination_handler termination_handler;
 
+    typedef typename connection_type::socket_type socket_type;
+
     // This would be ideal. Requires C++11 though
     //friend connection;
 
@@ -658,6 +660,9 @@ public:
         }
         return con;
     }
+    
+	void adopt_socket(const std::string& request, socket_type && socket);
+	
 protected:
     connection_ptr create_connection();
 
diff --git a/src/websocketpp/frame.hpp b/src/websocketpp/frame.hpp
index 18a990b..f883a66 100644
--- a/src/websocketpp/frame.hpp
+++ b/src/websocketpp/frame.hpp
@@ -831,7 +831,7 @@ inline size_t byte_mask_circ(uint8_t * input, uint8_t * output, size_t length,
     size_t prepared_key)
 {
     uint32_converter key;
-    key.i = prepared_key;
+    key.i = static_cast<uint32_t>(prepared_key);
 
     for (size_t i = 0; i < length; ++i) {
         output[i] = input[i] ^ key.c[i % 4];
diff --git a/src/websocketpp/impl/connection_impl.hpp b/src/websocketpp/impl/connection_impl.hpp
index bf88c95..d2beef7 100644
--- a/src/websocketpp/impl/connection_impl.hpp
+++ b/src/websocketpp/impl/connection_impl.hpp
@@ -982,7 +982,7 @@ void connection<config>::handle_read_frame(lib::error_code const & ec,
                 // just ignore it
                 m_alog->write(log::alevel::devel,"got eof from closed con");
                 return;
-            } else if (m_state == session::state::closing && !m_is_server) {
+            } else if (m_state == session::state::closing) {
                 // If we are a client we expect to get eof in the closing state,
                 // this is a signal to terminate our end of the connection after
                 // the closing handshake
diff --git a/src/websocketpp/impl/endpoint_impl.hpp b/src/websocketpp/impl/endpoint_impl.hpp
index 2aac1d9..c1b726c 100644
--- a/src/websocketpp/impl/endpoint_impl.hpp
+++ b/src/websocketpp/impl/endpoint_impl.hpp
@@ -32,6 +32,55 @@
 
 namespace websocketpp {
 
+template <typename connection, typename config>
+void endpoint<connection, config>::adopt_socket(const std::string& request, socket_type && socket) {
+    connection_ptr con = lib::make_shared<connection_type>(m_is_server,
+        m_user_agent, lib::ref(m_alog), lib::ref(m_elog), lib::ref(m_rng));
+
+    connection_weak_ptr w(con);
+
+    con->set_handle(w);
+
+    // Copy default handlers from the endpoint
+    con->set_open_handler(m_open_handler);
+    con->set_close_handler(m_close_handler);
+    con->set_fail_handler(m_fail_handler);
+    con->set_ping_handler(m_ping_handler);
+    con->set_pong_handler(m_pong_handler);
+    con->set_pong_timeout_handler(m_pong_timeout_handler);
+    con->set_interrupt_handler(m_interrupt_handler);
+    con->set_http_handler(m_http_handler);
+    con->set_validate_handler(m_validate_handler);
+    con->set_message_handler(m_message_handler);
+
+    if (m_open_handshake_timeout_dur != config::timeout_open_handshake) {
+        con->set_open_handshake_timeout(m_open_handshake_timeout_dur);
+    }
+    if (m_close_handshake_timeout_dur != config::timeout_close_handshake) {
+        con->set_close_handshake_timeout(m_close_handshake_timeout_dur);
+    }
+    if (m_pong_timeout_dur != config::timeout_pong) {
+        con->set_pong_timeout(m_pong_timeout_dur);
+    }
+    if (m_max_message_size != config::max_message_size) {
+        con->set_max_message_size(m_max_message_size);
+    }
+    con->set_max_http_body_size(m_max_http_body_size);
+
+    lib::error_code ec;
+
+    ec = transport_type::init(con);
+    ec = con->init_asio(socket.get_executor());
+
+    con->get_socket() = std::move(socket);
+    con->m_state = websocketpp::session::state::connecting;
+    con->m_internal_state = websocketpp::istate::READ_HTTP_REQUEST;
+
+    strncpy(con->m_buf, request.c_str(), request.size());
+
+    con->handle_read_handshake(lib::error_code(), request.size());
+}
+
 template <typename connection, typename config>
 typename endpoint<connection,config>::connection_ptr
 endpoint<connection,config>::create_connection() {
diff --git a/src/websocketpp/sha1/sha1.hpp b/src/websocketpp/sha1/sha1.hpp
index 6b48d95..6fd3fa2 100644
--- a/src/websocketpp/sha1/sha1.hpp
+++ b/src/websocketpp/sha1/sha1.hpp
@@ -173,7 +173,7 @@ inline void calc(void const * src, size_t bytelength, unsigned char * hash) {
         innerHash(result, w);
         clearWBuffert(w);
     }
-    w[15] = bytelength << 3;
+    w[15] = static_cast<unsigned int>(bytelength << 3);
     innerHash(result, w);
 
     // Store hash in result pointer, and make sure we get in in the correct
diff --git a/src/websocketpp/transport/asio/connection.hpp b/src/websocketpp/transport/asio/connection.hpp
index 0056d07..97a47e9 100644
--- a/src/websocketpp/transport/asio/connection.hpp
+++ b/src/websocketpp/transport/asio/connection.hpp
@@ -85,10 +85,14 @@ public:
     typedef typename config::response_type response_type;
     typedef typename response_type::ptr response_ptr;
 
-    /// Type of a pointer to the Asio executor being used
+    /// Type of Asio executor being used
+#if BOOST_VERSION < 107400    
     typedef lib::asio::executor executor_type;
+#else
+    typedef lib::asio::any_io_executor executor_type;
+#endif    
     /// Type of a pointer to the Asio strand<executor> being used
-    typedef lib::shared_ptr<lib::asio::strand<lib::asio::executor> > strand_ptr;
+    typedef lib::shared_ptr<lib::asio::strand<executor_type> > strand_ptr;
     /// Type of a pointer to the Asio timer class
     typedef lib::shared_ptr<lib::asio::steady_timer> timer_ptr;
 
@@ -406,7 +410,7 @@ public:
      * read or write the WebSocket handshakes. At this point the original
      * callback function is called.
      */
-protected:
+//protected:
     void init(init_handler callback) {
         if (m_alog->static_test(log::alevel::devel)) {
             m_alog->write(log::alevel::devel,"asio connection init");
@@ -461,7 +465,7 @@ protected:
         m_executor = executor;
 
         if (config::enable_multithreading) {
-            m_strand = lib::make_shared<lib::asio::strand<lib::asio::executor> >(
+            m_strand = lib::make_shared<lib::asio::strand<executor_type> >(
                 executor);
         }
 
diff --git a/src/websocketpp/transport/asio/endpoint.hpp b/src/websocketpp/transport/asio/endpoint.hpp
index 481c093..64abed7 100644
--- a/src/websocketpp/transport/asio/endpoint.hpp
+++ b/src/websocketpp/transport/asio/endpoint.hpp
@@ -77,8 +77,12 @@ public:
     /// associated with this endpoint transport component
     typedef typename transport_con_type::ptr transport_con_ptr;
 
-    /// Type of a pointer to the ASIO executor being used
+    /// Type of Asio executor being used
+#if BOOST_VERSION < 107400    
     typedef lib::asio::executor executor_type;
+#else
+    typedef lib::asio::any_io_executor executor_type;
+#endif    
     /// Type of a shared pointer to the acceptor being used
     typedef lib::shared_ptr<lib::asio::ip::tcp::acceptor> acceptor_ptr;
     /// Type of a shared pointer to the resolver being used
@@ -86,7 +90,7 @@ public:
     /// Type of timer handle
     typedef lib::shared_ptr<lib::asio::steady_timer> timer_ptr;
     /// Type of a shared pointer to an executor_work_guard object
-    typedef lib::shared_ptr<lib::asio::executor_work_guard<lib::asio::executor> > executor_work_guard_ptr;
+    typedef lib::shared_ptr<lib::asio::executor_work_guard<executor_type> > executor_work_guard_ptr;
 
     /// Type of socket pre-bind handler
     typedef lib::function<lib::error_code(acceptor_ptr)> tcp_pre_bind_handler;
@@ -365,7 +369,7 @@ public:
      *
      * @return A reference to the endpoint's executor
      */
-    lib::asio::executor get_executor() {
+    executor_type get_executor() {
         return m_executor;
     }
     
@@ -677,7 +681,7 @@ public:
      * @since 0.3.0
      */
     void start_perpetual() {
-        m_executor_work_guard = lib::make_shared<lib::asio::executor_work_guard<lib::asio::executor> >(
+        m_executor_work_guard = lib::make_shared<lib::asio::executor_work_guard<executor_type> >(
             m_executor
         );
     }
diff --git a/src/websocketpp/transport/asio/security/none.hpp b/src/websocketpp/transport/asio/security/none.hpp
index ce55db6..266567e 100644
--- a/src/websocketpp/transport/asio/security/none.hpp
+++ b/src/websocketpp/transport/asio/security/none.hpp
@@ -62,10 +62,14 @@ public:
     /// Type of a shared pointer to this connection socket component
     typedef lib::shared_ptr<type> ptr;
 
-    /// Type of a pointer to the Asio executor being used
+    /// Type of Asio executor being used
+#if BOOST_VERSION < 107400    
     typedef lib::asio::executor executor_type;
+#else
+    typedef lib::asio::any_io_executor executor_type;
+#endif    
     /// Type of a pointer to the Asio executor strand being used
-    typedef lib::shared_ptr<lib::asio::strand<lib::asio::executor> > strand_ptr;
+    typedef lib::shared_ptr<lib::asio::strand<executor_type> > strand_ptr;
     /// Type of the ASIO socket being used
     typedef lib::asio::ip::tcp::socket socket_type;
     /// Type of a shared pointer to the socket being used.
diff --git a/src/websocketpp/transport/asio/security/tls.hpp b/src/websocketpp/transport/asio/security/tls.hpp
index 67ef1c8..c92deea 100644
--- a/src/websocketpp/transport/asio/security/tls.hpp
+++ b/src/websocketpp/transport/asio/security/tls.hpp
@@ -71,10 +71,14 @@ public:
     typedef lib::asio::ssl::stream<lib::asio::ip::tcp::socket> socket_type;
     /// Type of a shared pointer to the ASIO socket being used
     typedef lib::shared_ptr<socket_type> socket_ptr;
-    /// Type of a pointer to the ASIO executor being used
+    /// Type of Asio executor being used
+#if BOOST_VERSION < 107400    
     typedef lib::asio::executor executor_type;
+#else
+    typedef lib::asio::any_io_executor executor_type;
+#endif    
     /// Type of a pointer to the ASIO executor strand being used
-    typedef lib::shared_ptr<lib::asio::strand<lib::asio::executor> > strand_ptr;
+    typedef lib::shared_ptr<lib::asio::strand<executor_type> > strand_ptr;
     /// Type of a shared pointer to the ASIO TLS context being used
     typedef lib::shared_ptr<lib::asio::ssl::context> context_ptr;
 
